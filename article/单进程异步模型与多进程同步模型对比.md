#单进程异步模型与多进程同步模型对比  
**作者: fergus (zfengzhen@gmail.com)**    

## 单进程异步模型  
主循环在很多回调点进行事件处理, 比如是否有网络包到来, 是否有共享内存消息到来, 是否有封装好的异步api的到来等, 有相应事件, 进行相应的处理, 碰到阻塞的操作(比如网络收发包, 数据库操作, 读写磁盘文件等), 异步处理, 释放CPU, 回到主循环.  

## 多进程同步模型  
单进程接收事件, 进行相应的处理, 碰到阻塞操作, 通过select进行同步发送, 以及接收, select设置超时时间.  
为了充分利用CPU, 开启多个上述相同的进程进行处理.  

## 性能  
假设单个事件中分为两大部分, 非阻塞操作(我们认为就是一些常用的系统调用, 以及读写内存操作)和阻塞操作(网络收发包, 数据库操作, 读写磁盘文件等).  
非阻塞操作耗时为x  
阻塞操作耗时为y  

理想情况下  
单进程异步模型的性能为:  1/x 次/s  
多进程同步模型的性能为:  n/(x+y) 次/s (n为进程数)

如果多进程同步模型的性能要好于单进程异步模型的性能, 则:  
n/(x+y) > 1/x  
y < (n-1)x  
也就是说阻塞操作的耗时要小于(n-1)倍非阻塞操作时间  
非阻塞操作中系统调用基本上都能达到每秒百万级别.  1/1000000 ~= 1ms 
内存的带宽为20G  
假设任务中要写1M的数据, 1M/20G ~= 0.05ms  

一次网络收发包设置的select超时为100ms, 实际情况下假如小于100ms, 也按100ms算, 因为最坏情况下会达到100ms   

100ms < (n-1)1ms  
则n > 101个, 开启进程数要大于101个, 才能达到单进程异步的性能.  
这只是理性情况下, 一个事件中只有一次网络收发包的情况, 实际情况下可能会有多次网络收发包的情况, 这样开启进程数要更多, 开启进程数越多的同时, 也会产生内耗, 导致性能的下降, 只能通过压测去评估最佳性能.  

## 柔性  
多进程同步模型中事件的超时时间取决于每个阻塞操作设置的超时时间, 某个阻塞操作超时了, 则整个事件超时, 柔性并不是很好. 遇到网络抖动的情况, 就全部超时.  
单进程异步模型中, 一般都会采用事件超时定时器, 超时是关联整个事件的, 只能整个事件超时才是超时, 柔性更强.  


